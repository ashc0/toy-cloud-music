## 轮播图思路
### 原理


### 实现思路
最初是想把所有的图片排成一行，装了所有图片的容器每次都平移一张图片宽度的距离，最后一张图片的时候直接移回最初的地方。但是这样不能实现首位连接滚动。
于是采用了条件渲染，只渲染当前下标的图片，并且是用 transition-group 列表过渡来实现过渡动画。transition的几个属性... vue中transition的几个css

### 问题
1. 转到其他路由，定时器并不会消失，仍然会执行回调。于是在 beforeDestroy 清楚定时器。

## 上拉加载更多
思路: 如果容器下沿进入了可视区域，则接着请求数据。
实现：利用 getBoundingClientRect() 获取容器下沿和视口的距离，如果此距离小于一定的值（视口高度 - footer高度）则代表进入了可视区域。由于数据的改变是发生在父组件中，于是使用this.$emit('getMore')，让父组件继续发起请求。

其他：需要做一个防抖处理，如果数据请求的途中仍然上拉则不会重新发起请求。在 vuex 中设立一个flag代表是否正在请求，如果正在请求，则不发起新请求，请求成功之后在nextTick中修改请求，因为必须要等待新数据渲染完成之后才算可以发起新请求，防止没渲染完成再次触底。为什么要用 vuex 呢？因为scroll 组件需要复用，flag是放在父组件里的，则每次复用都要在自己的父组件里写一个flag。

奇技淫巧：getMore 中 this.getlist(offset += 5) ，可以避免额外操作去改变 offset，代码更简洁。

## 歌单页面

为每个item绑定点击事件，点击之后把id emit 到父组件，路由跳转

## 可拖拽播放控制器 点击可展开