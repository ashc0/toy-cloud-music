## rem 怎么算？
先用一个机型，然后都用vh，看着顺眼之后就转成rem。除了一些确实和视口有关的

## 轮播图思路
### 原理


### 实现思路
自动轮播：最初是想把所有的图片排成一行，装了所有图片的容器每次都平移一张图片宽度的距离，最后一张图片的时候直接移回最初的地方。但是这样不能实现首位连接滚动。
于是采用了条件渲染，只渲染当前下标的图片，并且是用 transition-group 列表过渡来实现过渡动画。transition的几个属性... vue中transition的几个css

手动拖拽：
 - 判断是否到下一张 1：快速滑动 2：滑动距离长且离开区域位于尾部
 - 监听按下事件，一旦按下，显示前后图片于左右。每次滑动都同时控制三张图片的滑动

### 问题
1. 转到其他路由，定时器并不会消失，仍然会执行回调。于是在 beforeDestroy 清楚定时器。

## 上拉加载更多的scroll组件
思路: 如果容器下沿进入了可视区域，则接着请求数据。

实现：利用 getBoundingClientRect() 获取容器下沿和视口的距离，如果此距离小于一定的值（视口高度 - footer高度）则代表进入了可视区域。由于数据的改变是发生在父组件中，于是使用this.$emit('getMore')，让父组件继续发起请求。
### 防止多次请求
防止 touchmove 事件多次触发，使用节流。

如果数据请求的途中仍然上拉则不会重新发起请求,防止用户在数据到达之前多次下拉发出多次请求。

实现：在 vuex 中设立一个flag代表是否正在请求，如果正在请求，则不发起新请求，请求成功之后在nextTick中修改请求，因为必须要等待新数据渲染完成之后才算可以发起新请求，防止没渲染完成再次触底。为什么要用 vuex 呢？因为scroll 组件需要复用，flag是放在父组件里的，则每次复用都要在自己的父组件里写一个flag。

奇技淫巧：getMore 中 this.getlist(offset += 5) ，可以避免额外操作去改变 offset，代码更简洁。

### 事件委托
为每个 playlist 绑定一个 :data-id ，会在playlist组件最外层容器的 dataset 中拿到。把点击事件绑定到 scroll 上（@click.native），点击事件的默认参数 target为实际点击的节点。禁用掉playlist父容器下属所有的点击事件 CSS 设置 pointer-events:none。这样保证target一定是父容器的dom以便拿到 dataset。

## 歌单页面

1. 不定标题。判断detail是否在视口内，不在就把title改为歌单名字
2. 模糊背景图。在组件内添加一张图片，用绝对定位使其脱离文档流不影响其他元素布局，利用filter:blur(10px) 模糊化。z-index 设为负值不盖住其他元素。

### 点击收藏 长按播放 toast 提示  长按动效

## keep-alive
由于路由切换比较频繁。为路由设置 keep-alive ，保存失活的组件。但是会造成生命周期失效，于是把获取数据放在activated中

## 路由切换的滑动条问题
页面内共享同一滚动条。一个路由滚动了页面，路由跳转后滚动条还是上个路由的状态。于是把打算在路由跳转前 beforeRouteLeave 中存储当前的 pageOffset 于 meta（存储在路由信息中，可以在路由守卫中直接获取）。scrollBehavior 函数的返回值将会是路由的滚动条，于是直接将 meta 返回，可以实现滚动条互不影响，同时每次到歌单详情自动在顶部。

## 过渡与骨架屏
设置一个flag表示是否加载完毕，没加载完毕则用 v-show 隐藏数据页面并显示加载页面。activated 修改状态为未加载，数据加载完改为已加载

## 可拖拽播放控制器 点击可展开

@touchmove 会导致 body 滚动。于是使用 @touchmove.prevent 禁止默认事件

## 播放列表
1. 使用 overflow-y: scroll 和 max-height 来使超出则滚动
2. 将 localStorage 中的播放队列放入 vuex 中，各个功能使用的都是 vuex 中的数据。每次修改 vuex 中的数据时，都会同时修改 localStorage 为对应的值。
3. 如果 localStorage 中没有播放队列，则将其初始化为空数组的 JSON 格式

### 添加歌曲
点击为播放歌曲并添加入播放列表，长按则只加入播放列表而不播放。

将歌曲信息 push 到播放列表尾部，并且通过 every 方法判断是否之前就存在于播放列表中，不存在就添加。

### 缓存当前播放的歌曲
每次播放歌曲，将其添加入播放列表之后立刻 forEach 遍历播放列表，找到符合的歌曲下标并存入 vuex 和 localStorage。

当页面载入时，在生命周期钩子中拿到歌曲下标，并拿到上次播放的歌曲。但是此时 watch 并没有生效，于是无法根据 song 的改变而发起接口请求拿到歌曲的 url。于是在 created 中手动发起接口请求拿到初次的 url。

在 Chrome 中，刚载入页面时不能够自动播放。

### 歌曲播放机制
watch 监听 vuex 中 song 的变化。每次变化，都根据 id 发起接口请求拿到 url。


watch 监听 vuex 中 isPlaying 的变化。每次变化，在 nextTick 中都根据 isPlaying 的值修改 ref 来控制播放或暂停。也就是说只要任意地方控制 isPlaying 的状态都能够控制播放暂停。
缺点：如果上个歌曲正在播放，此时进入新的歌曲，由于没有设置 autoplay，所以不会自动播放。但是状态仍然是 isPlaying: true。于是可以在切换歌曲时，先将状态改为false，再发起接口请求去拿歌曲详情。