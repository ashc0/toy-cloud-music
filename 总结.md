## rem 怎么算？
先用一个机型，然后都用vh，看着顺眼之后就转成rem。除了一些确实和视口有关的

## 轮播图思路
### 原理


### 实现思路
自动轮播：最初是想把所有的图片排成一行，装了所有图片的容器每次都平移一张图片宽度的距离，最后一张图片的时候直接移回最初的地方。但是这样不能实现首位连接滚动。
于是采用了条件渲染，只渲染当前下标的图片，并且是用 transition-group 列表过渡来实现过渡动画。transition的几个属性... vue中transition的几个css

手动拖拽：
 - 判断是否到下一张 1：快速滑动 2：滑动距离长且离开区域位于尾部
 - 监听按下事件，一旦按下，显示前后图片于左右。每次滑动都同时控制三张图片的滑动

### 问题
1. 转到其他路由，定时器并不会消失，仍然会执行回调。于是在 beforeDestroy 清楚定时器。

## 上拉加载更多的scroll组件
思路: 如果容器下沿进入了可视区域，则接着请求数据。

实现：利用 getBoundingClientRect() 获取容器下沿和视口的距离，如果此距离小于一定的值（视口高度 - footer高度）则代表进入了可视区域。由于数据的改变是发生在父组件中，于是使用this.$emit('getMore')，让父组件继续发起请求。
### 防止多次请求 - 防抖
如果数据请求的途中仍然上拉则不会重新发起请求,防止用户在数据到达之前多次下拉发出多次请求。

实现：在 vuex 中设立一个flag代表是否正在请求，如果正在请求，则不发起新请求，请求成功之后在nextTick中修改请求，因为必须要等待新数据渲染完成之后才算可以发起新请求，防止没渲染完成再次触底。为什么要用 vuex 呢？因为scroll 组件需要复用，flag是放在父组件里的，则每次复用都要在自己的父组件里写一个flag。

奇技淫巧：getMore 中 this.getlist(offset += 5) ，可以避免额外操作去改变 offset，代码更简洁。

### 事件委托
为每个 playlist 绑定一个 :data-id ，会在playlist组件最外层容器的 dataset 中拿到。把点击事件绑定到 scroll 上（@click.native），点击事件的默认参数 target为实际点击的节点。禁用掉playlist父容器下属所有的点击事件 CSS 设置 pointer-events:none。这样保证target一定是父容器的dom以便拿到 dataset。

## 歌单页面

1. 不定标题。判断detail是否在视口内，不在就把title改为歌单名字
2. 模糊背景图。在组件内添加一张图片，用绝对定位使其脱离文档流不影响其他元素布局，利用filter:blur(10px) 模糊化。z-index 设为负值不盖住其他元素。

### 点击收藏 长按播放 toast 提示  长按动效

## keep-alive
由于路由切换比较频繁。为路由设置 keep-alive ，保存失活的组件。但是会造成生命周期失效，于是把获取数据放在activated中

## 路由切换的滑动条问题
页面内共享同一滚动条。一个路由滚动了页面，路由跳转后滚动条还是上个路由的状态。于是把打算在路由跳转前 beforeRouteLeave 中存储当前的 pageOffset 于 meta（存储在路由信息中，可以在路由守卫中直接获取）。scrollBehavior 函数的返回值将会是路由的滚动条，于是直接将 meta 返回，可以实现滚动条互不影响，同时每次到歌单详情自动在顶部。

## 过渡与骨架屏
设置一个flag表示是否加载完毕，没加载完毕则用 v-show 隐藏数据页面并显示加载页面。activated 修改状态为未加载，数据加载完改为已加载

## 可拖拽播放控制器 点击可展开

@touchmove 会导致 body 滚动。于是使用 @touchmove.prevent 禁止默认事件